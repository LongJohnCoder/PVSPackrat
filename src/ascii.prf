(arith_expr
 (IMP_semantic_parser_TCC1 0
  (IMP_semantic_parser_TCC2-1 nil 3780633724 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (IMP_semantic_parser subtype "arith_expr.V_N_b"
    "{k: naturalnumbers.nat | reals.>(k, 0)}")))
 (numeric_to_integer_TCC1 0
  (numeric_to_integer_TCC1-1 nil 3780633724 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (numeric_to_integer subtype "arith_expr.t"
                       "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].any?(x), booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].terminal?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].range?(x)))}")))
 (first_digit_TCC1 0
  (first_digit_TCC1-1 nil 3780633724 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil))
   nil
   (first_digit subtype "arith_expr.t2"
                "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].any?(x), booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].terminal?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].range?(x)))}")))
 (first_digit_TCC2 0
  (first_digit_TCC2-1 nil 3780633724 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil))
   nil
   (first_digit subtype "arith_expr.t1"
                "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (first_digit_TCC3 0
  (first_digit_TCC3-1 nil 3780633724 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil))
   nil
   (first_digit subtype
                "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(arith_expr.t1)"
                "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].any?(x), booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].terminal?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].range?(x)))}")))
 (aux_TCC1 0
  (aux_TCC1-1 nil 3780633724
   ("" (skeep*)
    (("" (typepred "ts")
      (("" (expand "astWellformed?" -1)
        (("" (replace -2 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (aux subtype "arith_expr.t1"
        "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (aux_TCC2 0
  (aux_TCC3-1 nil 3780633724 ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (aux termination
        "arith_expr.aux((number_fields.+)(number_fields.*(10, arith_expr.res), arith_expr.numeric_to_integer(arith_expr.t1)), arith_expr.t2)"
        "nil")))
 (left_assoc_op_TCC1 0
  (left_assoc_op_TCC1-1 nil 3780642054 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (left_assoc_op subtype "arith_expr.t"
                  "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].star?(x), booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].plus?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].opt?(x)))}")))
 (left_assoc_op_TCC2 0
  (left_assoc_op_TCC2-1 nil 3785828595 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (left_assoc_op subtype
                  "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T0(arith_expr.t)"
                  "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (left_assoc_op_TCC3 0
  (left_assoc_op_TCC2-1 nil 3780642054 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (left_assoc_op subtype "arith_expr.t"
                  "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].star?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].plus?(x))}")))
 (left_assoc_op_TCC4 0
  (left_assoc_op_TCC3-1 nil 3780642054 ("" (subtype-tcc) nil nil) nil
   nil
   (left_assoc_op subtype
                  "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].Ts(arith_expr.t)"
                  "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (left_assoc_op_TCC5 0
  (left_assoc_op_TCC4-1 nil 3780642054 ("" (termination-tcc) nil nil)
   ((ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (left_assoc_op termination
                  "arith_expr.left_assoc_op(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].Ts(arith_expr.t), arith_expr.op(arith_expr.res, pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].S(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T0(arith_expr.t)))), arith_expr.op)"
                  "nil"))))
(test_ascii
 (P_exp_TCC1 0
  (P_exp_TCC1-1 nil 3785834693
   ("" (assert) (("" (inst 1 "0") nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil))
   nil (P_exp existence "" "V_T")))
 (P_exp_TCC2 0
  (P_exp_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (P_exp subtype "arith_expr.V_N_b" "posnat")))
 (P_exp_TCC3 0
  (P_exp_TCC17-1 nil 3785828602 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC4 0
  (P_exp_TCC2-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC5 0
  (P_exp_TCC7-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC6 0
  (P_exp_TCC5-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC7 0
  (P_exp_TCC13-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC8 0
  (P_exp_TCC6-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC9 0
  (P_exp_TCC4-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC10 0
  (P_exp_TCC9-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "2" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC11 0
  (P_exp_TCC11-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC12 0
  (P_exp_TCC12-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "5" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC13 0
  (P_exp_TCC1-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "7" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC14 0
  (P_exp_TCC10-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "6" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC15 0
  (P_exp_TCC15-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "4" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC16 0
  (P_exp_TCC8-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "3" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC17 0
  (P_exp_TCC3-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "1" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC18 0
  (P_exp_TCC14-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "0" "naturalnumbers.below(arith_expr.V_N_b)")))
 (P_exp_TCC19 0
  (P_exp_TCC19-1 nil 3785834693 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" arith_expr nil)) nil
   (P_exp subtype "8" "naturalnumbers.below(arith_expr.V_N_b)")))
 (choose_prior_TCC1 0
  (choose_prior_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (choose_prior subtype "test_ascii.t"
                 "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (choose_prior_TCC2 0
  (choose_prior_TCC2-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil
   nil
   (choose_prior subtype
                 "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T1(test_ascii.t)"
                 "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (choose_prior_TCC3 0
  (choose_prior_TCC3-1 nil 3780642089 ("" (termination-tcc) nil nil)
   ((ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (choose_prior termination
                 "test_ascii.choose_prior(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T1(test_ascii.t))"
                 "nil")))
 (choose_prior_TCC4 0
  (choose_prior_TCC4-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil
   nil
   (choose_prior subtype
                 "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.t)"
                 "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (choose_prior_TCC5 0
  (choose_prior_TCC5-1 nil 3780642089 ("" (termination-tcc) nil nil)
   ((ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (reduce_nat adt-def-decl "[pre_ast -> nat]" pre_ast nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (astMeasure const-decl "nat" pre_ast nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (choose_prior termination
                 "test_ascii.choose_prior(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.t))"
                 "nil")))
 (P_inp_TCC1 0
  (P_inp_TCC1-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC2 0
  (P_inp_TCC3-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype
          "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.T)"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC3 0
  (P_inp_TCC2-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC4 0
  (P_inp_TCC8-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC5 0
  (P_inp_TCC5-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil nil
   (P_inp subtype
          "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.T)"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC6 0
  (P_inp_TCC4-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC7 0
  (P_inp_TCC7-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil nil
   (P_inp subtype
          "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.T)"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC8 0
  (P_inp_TCC6-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC9 0
  (P_inp_TCC13-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC10 0
  (P_inp_TCC10-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil nil
   (P_inp subtype
          "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.T)"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC11 0
  (P_inp_TCC9-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "{x: pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].pre_ast | booleans.OR(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].seq?(x), pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].prior?(x))}")))
 (P_inp_TCC12 0
  (P_inp_TCC12-1 nil 3780642089 ("" (subtype-tcc) nil nil) nil nil
   (P_inp subtype
          "pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].T2(test_ascii.T)"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (P_inp_TCC13 0
  (P_inp_TCC11-1 nil 3780642089 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_S type-eq-decl nil arith_expr nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (P_inp subtype "test_ascii.T"
          "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (entry_TCC1 0
  (entry_TCC1-1 nil 3780633797 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" test_ascii nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (entry subtype "9" "V_N")))
 (parser_semantic_TCC1 0
  (parser_semantic_TCC1-1 nil 3785828602
   ("" (skeep*)
    (("" (split)
      (("1" (expand "V_N_b") (("1" (propax) nil nil)) nil)
       ("2" (expand "strong_WF")
        (("2" (skeep)
          (("2" (case "A=0")
            (("1" (grind) nil nil)
             ("2" (case "A = 1")
              (("1" (grind) nil nil)
               ("2" (case "A=2")
                (("1" (grind) nil nil)
                 ("2" (case "A=3")
                  (("1" (grind) nil nil)
                   ("2" (case "A=4")
                    (("1" (grind) nil nil)
                     ("2" (case "A=5")
                      (("1" (grind) nil nil)
                       ("2" (case "A=6")
                        (("1" (grind) nil nil)
                         ("2" (case "A=7")
                          (("1" (grind) nil nil)
                           ("2" (case "A=8")
                            (("1" (grind) nil nil)
                             ("2" (case "A=9")
                              (("1" (grind) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (case "A=10")
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (typepred "A")
                                      (("2"
                                        (expand "V_N_b")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b const-decl "nat" test_ascii nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (compute_properties def-decl "F(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (aux def-decl "result" array_sum nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (recompute_nonTerminals_properties def-decl "C(P_exp)" wf_peg nil)
    (all_false const-decl "nTpred" wf_peg nil)
    (ρ const-decl "C(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (V_T type-eq-decl nil arith_expr nil)
    (restrict const-decl "R" restrict nil)
    (<= const-decl "bool" reals nil)
    (P_exp const-decl "[V_N -> Δ]" test_ascii nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parser_semantic subtype "test_ascii.P_exp"
                    "WF_nT[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b]")))
 (parser_semantic_TCC2 0
  (parser_semantic_TCC2-1 nil 3785828602 ("" (subtype-tcc) nil nil)
   ((V_N_b const-decl "nat" test_ascii nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (parser_semantic subtype "test_ascii.P_inp"
                    "semantic_interp[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (parser_semantic_TCC3 0
  (parser_semantic_TCC3-1 nil 3785828602 ("" (subtype-tcc) nil nil)
   ((entry const-decl "V_N" test_ascii nil)
    (V_N_b const-decl "nat" arith_expr nil))
   nil
   (parser_semantic subtype "test_ascii.entry"
                    "naturalnumbers.below(arith_expr.V_N_b)")))
 (parser_semantic_TCC4 0
  (parser_semantic_TCC4-1 nil 3785828602
   ("" (expand "entry_g")
    (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil)
   ((subterm adt-def-decl "boolean" peg nil)
    (entry_g const-decl "Δ" test_ascii nil))
   nil
   (parser_semantic subtype "test_ascii.entry_g"
                    "{e: wf_peg[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b].Δ | peg[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b].subterm(e, test_ascii.P_exp(test_ascii.entry))}")))
 (parser_semantic_TCC5 0
  (parser_semantic_TCC5-1 nil 3785828602
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parser_semantic subtype
                    "(LAMBDA (A: test_ascii.V_N, s: ast_props[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].inp_bound): semantic_parser[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].unknown)"
                    "semantic_parser[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].results(test_ascii.P_exp, test_ascii.P_inp, test_ascii.inp)")))
 (parser_semantic_TCC6 0
  (parser_semantic_TCC6-1 nil 3785828602
   ("" (skeep*)
    ((""
      (typepred
       "(sempp[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b,
                  100, V_S]
                (P_exp, P_inp, entry, entry_g, inp, 0, 0,
                 (LAMBDA (A: V_N,
                          s:
                            inp_bound
                                [V_T,
                                 restrict[[real, real], [V_T, V_T], bool]
                                     (<=),
                                 V_N_b, 100, V_S]):
                    unknown
                        [V_T, restrict[[real, real], [V_T, V_T], bool](<=),
                         V_N_b, 100, V_S]))`1)")
      (("1"
        (typepred
         "s_inp(P_inp, parsing(P_exp, entry, entry_g, inp, 0, 0))")
        (("1" (assert) nil nil)) nil)
       ("2" (assert)
        (("2" (expand "V_N_b") (("2" (propax) nil nil)) nil)) nil)
       ("3" (expand "V_N_b") (("3" (assert) nil nil)) nil)
       ("4" (expand "V_N_b") (("4" (propax) nil nil)) nil)
       ("5" (expand "V_N_b") (("5" (propax) nil nil)) nil)
       ("6" (expand "V_N_b") (("6" (propax) nil nil)) nil))
      nil))
    nil)
   ((unknown adt-constructor-decl "(unknown?)" semantic_parser nil)
    (unknown? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (entry_g const-decl "Δ" test_ascii nil)
    (entry const-decl "V_N" test_ascii nil)
    (P_inp const-decl "[V_N, semanticTree -> V_S]" test_ascii nil)
    (V_S type-eq-decl nil test_ascii nil)
    (P_exp const-decl "[V_N -> Δ]" test_ascii nil)
    (V_N type-eq-decl nil test_ascii nil)
    (V_N_b const-decl "nat" test_ascii nil)
    (sempp def-decl
     "[{T: pre_ast | T = s_inp(P_inp, parsing(P_exp, A, G, inp, s, s_T))},
 results(P_exp, P_inp, inp)]" semantic_parser nil)
    (results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (> const-decl "bool" reals nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S type-eq-decl nil arith_expr nil)
    (arith_expr type-decl nil arith_expr nil)
    (V_N_b const-decl "nat" arith_expr nil)
    (<= const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (V_T type-eq-decl nil arith_expr nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (total_order_restrict application-judgement "(total_order?[S])"
     restrict_order_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (parser_semantic subtype
                    "(semantic_parser[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].sempp(test_ascii.P_exp, test_ascii.P_inp, test_ascii.entry, test_ascii.entry_g, test_ascii.inp, 0, 0, (LAMBDA (A: test_ascii.V_N, s: ast_props[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].inp_bound): semantic_parser[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].unknown))`1)"
                    "ast[V_T, restrict[[real, real], [V_T, V_T], bool](<=), V_N_b, 100, V_S]")))
 (res_sem_TCC1 0
  (res_sem_TCC1-1 nil 3785828602 ("" (subtype-tcc) nil nil) nil nil
   (res_sem subtype "test_ascii.parser_semantic(test_ascii.inp)"
    "(pre_ast[V_T, restrict[[real, real], [V_T, V_T], booleans.bool].restrict(reals.<=), arith_expr.V_N_b, 100, arith_expr.V_S].semantic?)"))))

