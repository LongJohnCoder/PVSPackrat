(semantic_parser
 (results_TCC1 0
  (results_TCC1-1 nil 3774443161
   ("" (expand "subterm") (("" (propax) nil nil)) nil)
   ((subterm adt-def-decl "boolean" peg nil)) shostak
   (results subtype "semantic_parser.P_exp(semantic_parser.A)"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (results_TCC2 0
  (results_TCC2-1 nil 3774443161 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (results subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.P_exp(semantic_parser.A), semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC1 0
  (sempp_TCC52-1 nil 3776345577 ("" (assert) nil nil) nil nil
   (sempp subtype "semantic_parser.A"
    "naturalnumbers.upto(semantic_parser.V_N_b)")))
 (sempp_TCC2 0
  (sempp_TCC1-1 nil 3774443161 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s_T)"
    "nat")))
 (sempp_TCC3 0
  (sempp_TCC2-1 nil 3774443161 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s)"
    "nat")))
 (sempp_TCC4 0
  (sempp_TCC4-1 nil 3774443162
   ("" (skeep) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) shostak
   (sempp subtype "P_exp(semantic_parser.A)"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, P_exp(semantic_parser.A))}")))
 (sempp_TCC5 0
  (sempp_TCC5-1 nil 3774443162 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(P_exp(semantic_parser.A), semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC6 0
  (sempp_TCC7-1 nil 3774443162
   ("" (skeep*)
    (("" (typepred ("z`8" "z`7" "z`6" "z`5" "z`4"))
      (("" (assert) nil nil)) nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil) (astType type-decl nil ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (input type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.z`7)"
    "nat")))
 (sempp_TCC7 0
  (sempp_TCC3-1 nil 3774443162 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.z`6)"
    "nat")))
 (sempp_TCC8 0
  (sempp_TCC8-1 nil 3774443162 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s_T)"
    "nat")))
 (sempp_TCC9 0
  (sempp_TCC9-1 nil 3774443162 ("" (subtype-tcc) nil nil) nil shostak
   (sempp subtype
    "(number_fields.-)(semantic_parser.bound, semantic_parser.s)"
    "nat")))
 (sempp_TCC10 0
  (sempp_TCC11-1 nil 3774443163
   ("" (skeep*)
    (("" (replace -1 * LR) (("" (assert) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].ε(semantic_parser.s, semantic_parser.s))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC11 0
  (sempp_TCC6-1 nil 3774443162
   ("" (skeep)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (expand "s_inp")
          (("" (assert)
            (("" (lift-if)
              (("" (ground)
                (("1" (lift-if 1)
                  (("1" (assert)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (assert) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil))
   shostak
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].any(semantic_parser.s, real_defs.min(semantic_parser.bound, (number_fields.+)(semantic_parser.s, 1)), semantic_parser.inp(semantic_parser.s)))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC12 0
  (sempp_TCC10-1 nil 3774443162
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].terminal(semantic_parser.s, real_defs.min(semantic_parser.bound, (number_fields.+)(semantic_parser.s, 1)), semantic_parser.a, semantic_parser.inp(semantic_parser.s)))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC13 0
  (sempp_TCC12-1 nil 3774443168
   ("" (skeep*)
    (("" (replace -1 * LR) (("" (hide -1) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (astType? def-decl "astType" ast nil)
    (in_range const-decl "bool" ast nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].range(semantic_parser.s, real_defs.min(semantic_parser.bound, (number_fields.+)(semantic_parser.s, 1)), semantic_parser.a, semantic_parser.b, semantic_parser.inp(semantic_parser.s)))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC14 0
  (sempp_TCC21-1 nil 3774443187
   ("" (skeep)
    (("" (typepred "res")
      (("" (inst -1 "B" "s")
        (("" (assert)
          (("" (name "T_p" "parsing(P_exp, B, P_exp(B), inp, s, s)")
            (("" (replace -1 * LR)
              (("" (flatten)
                (("" (assert)
                  (("" (split -4)
                    (("1" (grind) nil nil)
                     ("2" (typepred "T_p")
                      (("2" (use "Wellformedness_is_meaningfulness")
                        (("2" (expand "astMeaningful?")
                          (("2" (assert)
                            (("2" (replace -12 * LR)
                              (("2"
                                (expand "parsing" +)
                                (("2"
                                  (replace -12 * LR)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (replace -9 * LR)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((results type-eq-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (input type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (astType? def-decl "astType" ast nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (astType type-decl nil ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (saved_result type-decl nil semantic_parser nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (astMeaningful? const-decl "bool" ast nil)
    (r const-decl "C(P_exp)" wf_peg nil)
    (array_sum const-decl "upto(3 * V_N_b)" array_sum nil)
    (nT_properties const-decl "F(P_exp)" wf_peg nil)
    (g_props def-decl "[bool, bool, bool]" wf_peg nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "semantic_parser.T(semantic_parser.res(semantic_parser.B, semantic_parser.s))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC15 0
  (sempp_TCC22-1 nil 3774443191
   ("" (skeep) (("" (expand "subterm") (("" (propax) nil nil)) nil))
    nil)
   ((subterm adt-def-decl "boolean" peg nil)) shostak
   (sempp subtype "semantic_parser.P_exp(semantic_parser.B)"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.B))}")))
 (sempp_TCC16 0
  (sempp_TCC23-1 nil 3774443191 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil) (peg type-decl nil peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (strong const-decl "bool" wf_peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype "semantic_parser.s"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.P_exp(semantic_parser.B), semantic_parser.B, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC17 0
  (sempp_TCC24-1 nil 3774443191 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.B, semantic_parser.P_exp(semantic_parser.B), semantic_parser.inp, semantic_parser.s, semantic_parser.s, semantic_parser.res)"
    "nil")))
 (sempp_TCC18 0
  (sempp_TCC26-1 nil 3774443196
   ("" (skeep)
    (("" (skeep)
      (("" (replace -1 * LR)
        (("" (expand "parsing")
          (("" (name "T_p" "parsing(P_exp, B, P_exp(B), inp, s, s)")
            (("" (replace -1 * LR)
              (("" (expand "s_inp")
                (("" (expand "astType?" 2)
                  (("" (assert)
                    (("" (typepred "T_B")
                      (("" (replace -2 * LR)
                        (("" (lemma "semantic_interp_type")
                          (("" (inst -1 "T_p" "P_inp")
                            (("" (replace -2 * LR)
                              ((""
                                (replace -2 * RL)
                                (("" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_type formula-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC19 0
  (sempp_TCC27-1 nil 3774443216 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B))"
    "(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].valuedTree?)")))
 (sempp_TCC20 0
  (sempp_TCC28-1 nil 3774443217
   ("" (skeep*)
    (("" (assert)
      (("" (lift-if -5)
        (("" (split -5)
          (("1" (flatten)
            (("1" (decompose-equality -1)
              (("1" (replace -1 * LR)
                (("1" (replace -2 * LR)
                  (("1" (assert)
                    (("1"
                      (name "T_p"
                            "parsing(P_exp, B, P_exp(B), inp, s, s)")
                      (("1" (replace -1 * LR)
                        (("1" (typepred "T_B")
                          (("1" (lemma "semantic_interp_type")
                            (("1" (inst -1 "T_p" "P_inp")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (lemma "semantic_interp_bounds")
                          (("2" (assert)
                            (("2" (expand "s_inp")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "P_exp")
                                  (("2"
                                    (expand "strong_WF")
                                    (("2" (inst -1 "B") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (expand "subterm") (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (flatten)
              (("2" (assert)
                (("2" (lift-if 3)
                  (("2" (assert)
                    (("2" (split 3)
                      (("1" (flatten) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2"
                            (name "T_p"
                                  "parsing(P_exp, A!1, P_exp(A!1), inp, s_1, s_1)")
                            (("1" (replace -1 * LR)
                              (("1"
                                (typepred "resB")
                                (("1"
                                  (inst -1 "A!1" "s_1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -2 * LR)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "P_exp")
                              (("2"
                                (expand "strong_WF")
                                (("2" (inst -1 "A!1") nil nil))
                                nil))
                              nil)
                             ("3" (expand "subterm")
                              (("3" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semantic_interp_type formula-decl nil semantic_interp nil)
    (semantic_interp_bounds formula-decl nil semantic_interp nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (results type-eq-decl nil semantic_parser nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B)))]"
    "semantic_parser.results(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.inp)")))
 (sempp_TCC21 0
  (sempp_TCC30-1 nil 3776062507
   ("" (skeep*)
    (("" (typepred "T_B")
      (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
        (("" (replace -1 * LR)
          (("" (lemma "semantic_interp_props")
            (("" (inst -1 "T_p" "P_inp")
              (("" (replace -3 * RL)
                (("" (flatten)
                  (("" (use "Wellformedness_is_meaningfulness")
                    (("" (expand "astMeaningful?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (sempp_TCC22 0
  (sempp_TCC30-1 nil 3774449978
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing")
        (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
          (("" (replace -1 * LR)
            (("" (expand "s_inp")
              (("" (expand "astType?" 3)
                (("" (lemma "semantic_interp_props")
                  (("" (inst -1 "T_p" "P_inp")
                    (("" (typepred "T_B")
                      (("" (replace -3 * LR)
                        (("" (replace -1 * RL)
                          (("" (flatten) (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.sem_T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC23 0
  (sempp_TCC31-1 nil 3774450009 ("" (subtype-tcc) nil nil)
   ((V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak
   (sempp subtype "semantic_parser.sem_T"
    "(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].valuedTree?)")))
 (sempp_TCC24 0
  (sempp_TCC32-1 nil 3774450010
   ("" (skeep*)
    (("" (lift-if -6)
      (("" (split -6)
        (("1" (flatten)
          (("1" (decompose-equality -1)
            (("1" (replace -1 * LR)
              (("1" (replace -2 * LR)
                (("1" (hide -1 -2)
                  (("1" (assert)
                    (("1"
                      (name "T_p"
                            " parsing(P_exp, B, P_exp(B), inp, s, s)")
                      (("1" (replace -1 * LR)
                        (("1" (lemma "semantic_interp_props")
                          (("1" (inst -1 "T_p" "P_inp")
                            (("1" (typepred "T_B")
                              (("1"
                                (replace -3 * LR)
                                (("1"
                                  (replace -1 * RL)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "P_exp")
                        (("2" (expand "strong_WF")
                          (("2" (inst -1 "B") nil nil)) nil))
                        nil)
                       ("3" (expand "subterm") (("3" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (typepred "resB")
            (("2" (inst -1 "A!1" "s_1")
              (("2" (assert)
                (("2"
                  (name "T_1" "parsing[V_T, <=, V_N_b, bound, V_S]
                        (P_exp, A!1, P_exp(A!1), inp, s_1, s_1)")
                  (("2" (replace -1 * LR)
                    (("2" (flatten)
                      (("2" (lift-if 4)
                        (("2" (split 4)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (split 2)
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil)
                                 ("3" (propax) nil nil)
                                 ("4" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (results type-eq-decl nil semantic_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil) (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil) (WF_nT type-eq-decl nil wf_peg nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (below type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(semantic_parser.sem_T)]"
    "semantic_parser.results(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.inp)")))
 (sempp_TCC25 0
  (sempp_TCC35-1 nil 3776062507
   ("" (skeep*)
    (("" (typepred "T_B")
      (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
        (("" (replace -1 * LR)
          (("" (lemma "semantic_interp_props")
            (("" (inst -1 "T_p" "P_inp")
              (("" (flatten)
                (("" (replace -6 * RL)
                  (("" (use "Wellformedness_is_meaningfulness")
                    (("" (expand "astMeaningful?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T_B"
    "semanticTree[V_T, <=, V_N_b, bound, V_S]")))
 (sempp_TCC26 0
  (sempp_TCC34-1 nil 3774450059
   ("" (skeep)
    (("" (skeep)
      (("" (skeep)
        (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
          (("1" (lemma "semantic_interp_props")
            (("1" (inst -1 "T_p" "P_inp")
              (("1" (flatten)
                (("1" (typepred "T_B")
                  (("1" (replace -6 * LR)
                    (("1" (replace -1 * RL)
                      (("1" (use "Wellformedness_is_meaningfulness")
                        (("1" (expand "astMeaningful?")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "P_exp")
            (("2" (expand "strong_WF") (("2" (inst -1 "B") nil nil))
              nil))
            nil)
           ("3" (expand "subterm") (("3" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (semantic_interp_props formula-decl nil semantic_interp nil))
   shostak
   (sempp subtype "semantic_parser.sem_T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC27 0
  (sempp_TCC35-1 nil 3774450090
   ("" (skeep*)
    (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
      (("1" (lemma "semantic_interp_props")
        (("1" (inst -1 "T_p" "P_inp")
          (("1" (typepred "T_B")
            (("1" (replace -6 * LR)
              (("1" (use "Wellformedness_is_meaningfulness")
                (("1" (expand "astMeaningful?")
                  (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "P_exp")
        (("2" (expand "strong_WF") (("2" (inst -1 "B") nil nil)) nil))
        nil)
       ("3" (assert)
        (("3" (expand "subterm") (("3" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ast type-eq-decl nil ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (<= const-decl "bool" reals nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.sem_T"
    "(semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].valuedTree?)")))
 (sempp_TCC28 0
  (sempp_TCC36-1 nil 3774450090
   ("" (skeep*)
    (("" (hide 4)
      (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
        (("1" (lemma "semantic_interp_props")
          (("1" (inst -1 "T_p" "P_inp")
            (("1" (typepred "T_B")
              (("1" (replace -6 * LR)
                (("1" (use "Wellformedness_is_meaningfulness")
                  (("1" (expand "astMeaningful?")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "P_exp")
          (("2" (expand "strong_WF") (("2" (inst -1 "B") nil nil))
            nil))
          nil)
         ("3" (assert)
          (("3" (expand "subterm") (("3" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((semantic_interp_props formula-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(semantic_parser.sem_T)]"
    "semantic_parser.results(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.inp)")))
 (sempp_TCC29 0
  (sempp_TCC37-1 nil 3774450138
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp disjointness
    "COND ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].astType?(semantic_parser.T_B) = ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure -> (pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B)), semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B)))]), ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].astType?(semantic_parser.T_B) = ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success -> LET sem_T = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semantic(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B), semantic_parser.B, semantic_parser.P_inp(semantic_parser.B, semantic_parser.T_B)) IN (semantic_parser.sem_T, semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(semantic_parser.sem_T)]) ENDCOND"
    "nil")))
 (sempp_TCC30 0
  (sempp_TCC38-1 nil 3774450139
   ("" (skeep*)
    (("" (assert)
      (("" (name "T_p" " parsing(P_exp, B, P_exp(B), inp, s, s)")
        (("1" (lemma "semantic_interp_props")
          (("1" (inst -1 "T_p" "P_inp")
            (("1" (typepred "T_B")
              (("1" (replace -6 * LR)
                (("1" (use "Wellformedness_is_meaningfulness")
                  (("1" (expand "astMeaningful?")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (typepred "P_exp")
          (("2" (expand "strong_WF") (("2" (inst -1 "B") nil nil))
            nil))
          nil)
         ("3" (assert)
          (("3" (expand "subterm") (("3" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((semantic_interp_props formula-decl nil semantic_interp nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Wellformedness_is_meaningfulness formula-decl nil ast nil)
    (astMeaningful? const-decl "bool" ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (<= const-decl "bool" reals nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp coverage
    "COND ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].astType?(semantic_parser.T_B) = ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].failure -> (pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B)), semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B)))]), ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].astType?(semantic_parser.T_B) = ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].success -> LET sem_T = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semantic(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T_B), semantic_parser.B, semantic_parser.P_inp(semantic_parser.B, semantic_parser.T_B)) IN (semantic_parser.sem_T, semantic_parser.resB WITH [(semantic_parser.B, semantic_parser.s) := semantic_parser.known(semantic_parser.sem_T)]) ENDCOND"
    "nil")))
 (sempp_TCC31 0
  (sempp_TCC39-1 nil 3774450152
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (assert)
          (("" (replace -1 * LR)
            (("" (expand "subterm")
              (("" (expand "subterm") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e1"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC32 0
  (sempp_TCC40-1 nil 3774450155
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (flatten)
            (("" (replace -4 * LR) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e1, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC33 0
  (sempp_TCC41-1 nil 3774450157
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sum const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e1, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC34 0
  (sempp_TCC43-1 nil 3774450232
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (expand "parsing" 1)
        (("" (typepred "T1")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
            (("" (assert)
              (("" (expand "s_inp" 2)
                (("" (expand "astType?" 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC35 0
  (sempp_TCC44-1 nil 3774457949
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e2" "G" "P_exp(A)")
        (("" (assert) (("" (hide 2 3) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e2"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC36 0
  (sempp_TCC46-1 nil 3774591301
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (typepred "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
        (("" (assert)
          (("" (assert)
            (("" (typepred "s_T")
              (("" (use "Wellformed_theorem")
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (flatten)
                        (("" (assert)
                          (("" (replace -16 * LR)
                            (("" (expand "g_wf" -4)
                              ((""
                                (flatten)
                                ((""
                                  (assert)
                                  ((""
                                    (expand "strong")
                                    ((""
                                      (typepred
                                       "parsing(P_exp, A, e1, inp, s, s_T)")
                                      (("" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e2, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC37 0
  (sempp_TCC47-1 nil 3774591327
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (flatten)
            (("" (typepred "T1")
              (("" (name "T1_p" "parsing(P_exp, A, e1, inp, s, s_T)")
                (("" (lemma "semantic_interp_props")
                  (("" (inst -1 "T1_p" "P_inp")
                    (("" (replace -2 * LR)
                      (("" (replace -3 * RL)
                        (("" (flatten)
                          (("" (use "Consumption_growth")
                            (("" (assert)
                              ((""
                                (replace -8 * LR)
                                ((""
                                  (hide - 1 2)
                                  (("" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (Consumption_growth formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e2, semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1), semantic_parser.s_T, semantic_parser.res1)"
    "nil")))
 (sempp_TCC38 0
  (sempp_TCC49-1 nil 3774591350
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (name "T1_p" "parsing(P_exp, A, e1, inp, s, s_T)")
        (("" (replace -1 * LR)
          (("" (typepred "T1_p")
            (("" (typepred "s_inp(P_inp, T1_p)")
              (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.T1"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC39 0
  (sempp_TCC53-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (typepred "T2")
        (("" (typepred "parsing(P_exp, A, e2, inp, e(T1), s_T)")
          (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
            (("" (assert)
              ((""
                (typepred
                 "s_inp(P_inp, parsing(P_exp, A, e2, inp, e(T1), s_T))")
                ((""
                  (typepred
                   "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
                  (("" (assert)
                    (("" (assert)
                      (("" (expand "semppCompact")
                        (("" (expand "astType?" 7)
                          (("" (replace -42 * LR)
                            (("" (expand "parsing" 7)
                              ((""
                                (lift-if 7)
                                ((""
                                  (split 7)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "s_inp" 1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand "astType?" 1)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (split 2)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (expand "s_inp" 1)
                                            (("1"
                                              (expand "astType?" 1)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (expand "s_inp" 2)
                                            (("2"
                                              (expand "astType?" 2)
                                              (("2"
                                                (lift-if 2)
                                                (("2"
                                                  (split 2)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (split 2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (semppCompact const-decl "pre_ast" semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semppCompact(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].seq(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2), semantic_parser.T1, semantic_parser.T2), semantic_parser.G)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC40 0
  (sempp_TCC51-1 nil 3774869098
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e1" "G" "P_exp(A)")
        (("" (assert)
          (("" (expand "subterm")
            (("" (replace -1 * LR)
              (("" (expand "subterm") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.e1"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC41 0
  (sempp_TCC52-1 nil 3774869141
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (expand "g_wf" -)
        (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e1, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC42 0
  (sempp_TCC53-1 nil 3774869172
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e1, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC43 0
  (sempp_TCC55-1 nil 3774869248
   ("" (skeep*) (("" (grind) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (astType? def-decl "astType" ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak
   (sempp subtype "semantic_parser.T1"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC44 0
  (sempp_TCC59-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T1")
      ((""
        (typepred "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
          (("" (assert)
            (("" (replace -21 * LR)
              (("" (expand "parsing" 4)
                (("" (expand "s_inp" 4)
                  (("" (expand "astType?" 4)
                    (("" (assert)
                      (("" (decompose-equality 4)
                        (("" (expand "s_inp" 1)
                          (("" (expand "astType?")
                            (("" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (pre_ast_prior_extensionality formula-decl nil pre_ast nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].prior(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1), semantic_parser.T1, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip(semantic_parser.s, semantic_parser.s, semantic_parser.e2))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC45 0
  (sempp_TCC57-1 nil 3775125996
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e2" "G" "P_exp(A)")
        (("" (assert)
          (("" (hide 2 3)
            (("" (expand "subterm")
              (("" (replace -1 * LR)
                (("" (assert)
                  (("" (flatten)
                    (("" (expand "subterm") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e2"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC46 0
  (sempp_TCC58-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -2)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e2, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC47 0
  (sempp_TCC59-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (sum const-decl "nat" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e2, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res1)"
    "nil")))
 (sempp_TCC48 0
  (sempp_TCC61-1 nil 3775125996
   ("" (skeep*)
    (("" (lemma "sem_output_props")
      (("" (inst -1 "P_exp" "P_inp" "A" "e1" "inp" "b" "s" "s_T" "T1")
        (("1" (assert) nil nil)
         ("2" (typepred "s_T") (("2" (assert) nil nil)) nil)
         ("3" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
          (("3" (inst -1 "e1" "G" "P_exp(A)") (("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s(semantic_parser.T1), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC49 0
  (sempp_TCC65-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T1")
      (("" (typepred "T2")
        (("" (typepred "parsing(P_exp, A, e2, inp, s, s_T)")
          (("" (typepred "parsing(P_exp, A, e1, inp, s, s_T)")
            ((""
              (typepred
               "s_inp(P_inp, parsing(P_exp, A, e2, inp, s, s_T))")
              ((""
                (typepred
                 "s_inp(P_inp, parsing(P_exp, A, e1, inp, s, s_T))")
                (("" (expand "semppCompact")
                  (("" (expand "astType?" 4)
                    (("" (expand "astType?" 4 1)
                      (("" (expand "astType?" 4 1)
                        (("" (expand "astType?" 4 2)
                          (("" (replace -45 * LR)
                            (("" (expand "parsing" 4)
                              ((""
                                (lemma "Wellformed_theorem")
                                ((""
                                  (inst
                                   -1
                                   "parsing(P_exp, A, e1, inp, s, s_T)")
                                  ((""
                                    (lemma "Wellformed_theorem")
                                    ((""
                                      (inst
                                       -1
                                       "parsing(P_exp, A, e2, inp, s, s_T)")
                                      ((""
                                        (assert)
                                        ((""
                                          (assert)
                                          ((""
                                            (flatten)
                                            ((""
                                              (split -2)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "s_inp" 6)
                                                  (("1"
                                                    (expand
                                                     "astType?"
                                                     6
                                                     1)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (expand
                                                   "astType?"
                                                   6
                                                   1)
                                                  (("2"
                                                    (expand "s_inp" 7)
                                                    (("2"
                                                      (expand
                                                       "astType?"
                                                       7
                                                       1)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (decompose-equality
                                                           9)
                                                          (("2"
                                                            (expand
                                                             "s_inp"
                                                             1)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semppCompact const-decl "pre_ast" semantic_interp nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (prior adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)}, pre_ast] -> (prior?)]"
     pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (pre_ast_prior_extensionality formula-decl nil pre_ast nil)
    (prior? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semppCompact(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].prior(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T2), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s(semantic_parser.T1), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T1)), semantic_parser.T2), semantic_parser.G)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC50 0
  (sempp_TCC63-1 nil 3775125996
   ("" (skeep)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil))
   nil
   (sempp subtype "semantic_parser.e"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC51 0
  (sempp_TCC64-1 nil 3775125996
   ("" (skeep)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (expand "g_wf" -2) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC52 0
  (sempp_TCC65-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (replace -1 * LR) (("" (hide -) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (inc const-decl "nat" peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC53 0
  (sempp_TCC67-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      (("" (assert)
        (("" (expand "sem_output?")
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC54 0
  (sempp_TCC71-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (assert)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (lemma "Wellformed_theorem")
                (("" (inst -1 "parsing(P_exp, A, e, inp, s, s_T)")
                  (("" (assert)
                    (("" (expand "s_inp" 3)
                      (("" (expand "astType?" 3)
                        (("" (assert)
                          (("" (assert)
                            (("" (lemma "Wellformed_theorem")
                              ((""
                                (inst
                                 -1
                                 "parsing(P_exp, A, e, inp, s, s_T)")
                                ((""
                                  (assert)
                                  ((""
                                    (expand "parsing" 5)
                                    ((""
                                      (assert)
                                      ((""
                                        (expand "s_inp" 5)
                                        ((""
                                          (assert)
                                          ((""
                                            (expand "astType?" 5)
                                            ((""
                                              (assert)
                                              ((""
                                                (decompose-equality 5)
                                                ((""
                                                  (replace -22 * LR)
                                                  ((""
                                                    (decompose-equality
                                                     1)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pre_ast_fail_extensionality formula-decl nil pre_ast nil)
    (pre_ast_star_extensionality formula-decl nil pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (skip adt-constructor-decl
          "[[below, below, peg[V_T, <=, V_N_b]] -> (skip?)]" pre_ast
          nil)
    (star adt-constructor-decl
     "[[below, below, {T: pre_ast | ¬skip?(T)},
  {T: pre_ast | skip?(T) OR star?(T)}] ->
   (star?)]" pre_ast nil)
    (¬ const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star(semantic_parser.s, semantic_parser.s, semantic_parser.T0, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e)))"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC55 0
  (sempp_TCC69-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "G")
      (("" (replace -2 * LR) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e)"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC56 0
  (sempp_TCC71-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (replace -25 * LR)
                      (("" (split -21)
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e), semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC57 0
  (sempp_TCC72-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (typepred "P_exp")
                      (("" (lemma "strong_is_complete_WF")
                        (("" (inst -1 "P_exp")
                          (("" (lemma "complete_WF_theorem")
                            (("" (inst -1 "P_exp" "A" "G")
                              ((""
                                (typepred "G")
                                ((""
                                  (replace -27 * LR)
                                  ((""
                                    (assert)
                                    ((""
                                      (expand "g_wf")
                                      (("" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (pegMeasure const-decl "nat" peg nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].star(semantic_parser.e), semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), semantic_parser.s_T, semantic_parser.res0)"
    "nil")))
 (sempp_TCC58 0
  (sempp_TCC74-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T1" "T0")
      (("" (typepred "T1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC59 0
  (sempp_TCC78-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, star(e), inp, e(T0), s_T))")
                      ((""
                        (typepred
                         "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                        (("" (use "Wellformed_theorem" ("T" "Ts"))
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.Ts"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star?(T))}")))
 (sempp_TCC60 0
  (sempp_TCC79-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, star(e), inp, e(T0), s_T))")
                      ((""
                        (typepred
                         "parsing(P_exp, A, star(e), inp, e(T0), s_T)")
                        (("" (use "Wellformed_theorem" ("T" "Ts"))
                          (("" (assert)
                            (("" (flatten)
                              ((""
                                (assert)
                                ((""
                                  (replace -44 * LR)
                                  ((""
                                    (assert)
                                    ((""
                                      (expand "s_inp" 8)
                                      ((""
                                        (expand "parsing" 8)
                                        ((""
                                          (expand "astType?" 8)
                                          (("" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (star adt-constructor-decl "[peg -> (star?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].star(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.Ts), semantic_parser.T0, semantic_parser.Ts)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC61 0
  (sempp_TCC77-1 nil 3775125996
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (assert)
          (("" (replace -1 * LR)
            (("" (expand "subterm")
              (("" (expand "subterm") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC62 0
  (sempp_TCC78-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (replace -3 * LR)
        (("" (expand "g_wf" -) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC63 0
  (sempp_TCC79-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (rewrite "lex3_lt")
        (("" (rewrite "lex2_lt")
          (("" (replace -1 * LR) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (pegMeasure const-decl "nat" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC64 0
  (sempp_TCC81-1 nil 3775125996
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert)
                (("" (assert)
                  (("" (expand "parsing" 4)
                    (("" (expand "s_inp" 4)
                      (("" (expand "astType?" 4)
                        (("" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail(semantic_parser.s, semantic_parser.s)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC65 0
  (sempp_TCC82-1 nil 3775125996 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp subtype
    "peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e)"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC66 0
  (sempp_TCC84-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "s_T")
                    (("" (replace -24 * LR)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)) | booleans.⇒((k = pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0)), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e), semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC67 0
  (sempp_TCC85-1 nil 3775125996
   ("" (skeep*)
    (("" (rewrite "lex4_lt")
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (use "Wellformed_theorem" ("T" "T0"))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (typepred "P_exp")
                        (("" (use "strong_is_complete_WF")
                          (("" (lemma "complete_WF_theorem")
                            (("" (inst -1 "P_exp" "A" "G")
                              ((""
                                (typepred "G")
                                ((""
                                  (assert)
                                  ((""
                                    (replace -27 * LR)
                                    ((""
                                      (expand "g_wf")
                                      (("" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (lex4_lt formula-decl nil lex4 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (peg type-decl nil peg nil) (g_wf def-decl "bool" wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (pegMeasure const-decl "nat" peg nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (strong_is_complete_WF formula-decl nil wf_peg nil)
    (complete_WF_theorem formula-decl nil wf_peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].plus(semantic_parser.e), semantic_parser.inp, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T0), semantic_parser.s_T, semantic_parser.res0)"
    "nil")))
 (sempp_TCC68 0
  (sempp_TCC87-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T0"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC69 0
  (sempp_TCC91-1 nil 3777620320
   ("" (skeep*)
    (("" (typepred "T0")
      ((""
        (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
        (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (use "Wellformed_theorem" ("T" "T0"))
            (("" (assert)
              (("" (flatten)
                (("" (assert)
                  (("" (typepred "Ts")
                    ((""
                      (typepred
                       " s_inp(P_inp, parsing(P_exp, A, plus(e), inp, e(T0), s_T))")
                      ((""
                        (typepred
                         "parsing(P_exp, A, plus(e), inp, e(T0), s_T)")
                        (("" (use "Wellformed_theorem" ("T" "Ts"))
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.Ts"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T), booleans.OR(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].plus?(T), pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].fail?(T)))}")))
 (sempp_TCC70 0
  (sempp_TCC92-1 nil 3777620320
   ("" (skeep*)
    (("" (replace -1 * LR)
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert)
                (("" (flatten)
                  (("" (assert)
                    (("" (typepred "Ts")
                      ((""
                        (typepred
                         " s_inp(P_inp, parsing(P_exp, A, plus(e), inp, e(T0), s_T))")
                        ((""
                          (typepred
                           "parsing(P_exp, A, plus(e), inp, e(T0), s_T)")
                          (("" (use "Wellformed_theorem" ("T" "Ts"))
                            (("" (assert)
                              ((""
                                (flatten)
                                ((""
                                  (assert)
                                  ((""
                                    (expand "parsing" 8)
                                    ((""
                                      (expand "s_inp" 8)
                                      ((""
                                        (expand "astType?" 8)
                                        ((""
                                          (lift-if 8)
                                          ((""
                                            (split 8)
                                            (("1"
                                              (flatten)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split 2)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Wellformed_theorem formula-decl nil ast nil)
    (plus adt-constructor-decl "[peg -> (plus?)]" peg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].plus(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.Ts), semantic_parser.T0, semantic_parser.Ts)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC71 0
  (sempp_TCC90-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "G")
      (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
        (("" (inst -1 "e" "G" "P_exp(A)")
          (("" (assert)
            (("" (replace -2 * LR)
              (("" (hide 2 3 4 -)
                (("" (expand "subterm")
                  (("" (expand "subterm") (("" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_transitivity formula-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC72 0
  (sempp_TCC91-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -4 * LR)
            (("" (assert)
              (("" (replace -3 * LR) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC73 0
  (sempp_TCC92-1 nil 3775125996 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC74 0
  (sempp_TCC94-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (typepred "T0")
        ((""
          (typepred " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
          (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (use "Wellformed_theorem" ("T" "T0"))
              (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC75 0
  (sempp_TCC98-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (use "Wellformed_theorem" ("T" "T0"))
                (("" (assert)
                  (("" (assert)
                    (("" (expand "parsing" 4)
                      (("" (expand "s_inp" 4)
                        (("" (expand "astType?" 4)
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].opt(semantic_parser.s, semantic_parser.s, semantic_parser.T)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC76 0
  (sempp_TCC97-1 nil 3775125996
   ("" (skeep*)
    (("" (name-replace "T1" "T!1")
      (("" (typepred "T1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC77 0
  (sempp_TCC101-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (use "Wellformed_theorem" ("T" "T0"))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (expand "parsing" 5)
                        (("" (expand "s_inp" 5)
                          (("" (expand "astType?" 5)
                            (("" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].opt(semantic_parser.s, pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].e(semantic_parser.T), semantic_parser.T)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC78 0
  (sempp_TCC99-1 nil 3775125996
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (assert)
          (("" (replace -1 * LR)
            (("" (expand "subterm")
              (("" (expand "subterm") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC79 0
  (sempp_TCC100-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC80 0
  (sempp_TCC101-1 nil 3775125996 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC81 0
  (sempp_TCC103-1 nil 3775125996
   ("" (skeep)
    (("" (skeep)
      (("" (name-replace "T1" "T!1")
        (("" (typepred "T1")
          (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
            (("" (replace -1 * LR)
              (("" (lemma "semantic_interp_props")
                (("" (inst -1 "T1_p" "P_inp")
                  (("" (replace -3 * RL)
                    (("" (flatten)
                      (("" (expand "astWellformed?")
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_interp_props formula-decl nil semantic_interp nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC82 0
  (sempp_TCC107-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (use "Wellformed_theorem" ("T" "T0"))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (expand "parsing" 3)
                        (("" (expand "s_inp" 3)
                          (("" (expand "astType?" 3)
                            (("" (lift-if 3)
                              ((""
                                (expand "semppCompact")
                                ((""
                                  (split 3)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (lift-if 1)
                                      (("1"
                                        (split 1)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "astType?" 1)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lift-if 2)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand "astType?" -1)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semppCompact const-decl "pre_ast" semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semppCompact(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].notP(semantic_parser.s, semantic_parser.s, semantic_parser.T), semantic_parser.G)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}")))
 (sempp_TCC83 0
  (sempp_TCC105-1 nil 3775125996
   ("" (skeep*)
    (("" (lemma "peg[V_T, <=, V_N_b].subterm_transitivity")
      (("" (inst -1 "e" "G" "P_exp(A)")
        (("" (assert)
          (("" (replace -1 * LR)
            (("" (expand "subterm")
              (("" (expand "subterm") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (subterm_transitivity formula-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.e"
    "{e: wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].Δ | peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].subterm(e, semantic_parser.P_exp(semantic_parser.A))}")))
 (sempp_TCC84 0
  (sempp_TCC106-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "s_T")
      (("" (assert)
        (("" (expand "g_wf" -)
          (("" (replace -3 * LR) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (subterm adt-def-decl "boolean" peg nil)
    (g_wf def-decl "bool" wf_peg nil) (peg type-decl nil peg nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.s_T"
    "{k: naturalnumbers.upto(semantic_parser.s) | booleans.⇒((k = semantic_parser.s), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].g_wf(semantic_parser.e, semantic_parser.A, wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].P_0c?(semantic_parser.P_exp), wf_peg[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b].strong))}")))
 (sempp_TCC85 0
  (sempp_TCC107-1 nil 3775125996 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (peg type-decl nil peg nil) (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" peg nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (saved_result type-decl nil semantic_parser nil)
    (known? adt-recognizer-decl "[saved_result -> boolean]"
     semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (astType type-decl nil ast nil) (pre_ast type-decl nil pre_ast nil)
    (astType? def-decl "astType" ast nil)
    (input type-eq-decl nil ast_props nil)
    (astWellformed? def-decl "bool" ast nil)
    (ast type-eq-decl nil ast nil) (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (valuedTree? const-decl "bool" semantic_interp nil)
    (T adt-accessor-decl "[(known?) -> (valuedTree?)]" semantic_parser
     nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (fail adt-constructor-decl "[[below, below] -> (fail?)]" pre_ast
     nil)
    (semantic? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (semantic adt-constructor-decl
     "[[below, below, V_N[V_N_b], V_S] -> (semantic?)]" pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (results type-eq-decl nil semantic_parser nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (inc const-decl "nat" peg nil)
    (reduce_nat adt-def-decl "[peg -> nat]" peg nil)
    (< def-decl "bool" ordinals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (pegMeasure const-decl "nat" peg nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (lex3 const-decl "ordinal" lex3 nil)
    (lex4 const-decl "ordinal" lex4 nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (sempp termination
    "semantic_parser.sempp(semantic_parser.P_exp, semantic_parser.P_inp, semantic_parser.A, semantic_parser.e, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T, semantic_parser.res)"
    "nil")))
 (sempp_TCC86 0
  (sempp_TCC109-1 nil 3775125996
   ("" (skeep*)
    (("" (typepred "T!1")
      (("" (name-replace "T1" "T!1")
        (("" (name "T1_p" "parsing(P_exp, A, e, inp, s, s_T)")
          (("" (replace -1 * LR)
            (("" (lemma "semantic_interp_props")
              (("" (inst -1 "T1_p" "P_inp")
                (("" (replace -3 * RL)
                  (("" (flatten)
                    (("" (expand "astWellformed?")
                      (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (output type-eq-decl nil peg_parser nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (trueToInput def-decl "bool" ast_props nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (ast type-eq-decl nil ast nil)
    (strong const-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (g_wf def-decl "bool" wf_peg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (input type-eq-decl nil ast_props nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (peg type-decl nil peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (astWellformed? def-decl "bool" ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (below type-eq-decl nil pre_ast nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (astType? def-decl "astType" ast nil)
    (astType type-decl nil ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pre_ast type-decl nil pre_ast nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (V_T formal-nonempty-type-decl nil semantic_parser nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic_interp_props formula-decl nil semantic_interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype "semantic_parser.T"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | (booleans.¬)(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].skip?(T))}")))
 (sempp_TCC87 0
  (sempp_TCC113-1 nil 3777620320
   ("" (skeep*)
    (("" (name-replace "T0" "T!1")
      (("" (replace -1 * LR)
        (("" (typepred "T0")
          ((""
            (typepred
             " s_inp(P_inp, parsing(P_exp, A, e, inp, s, s_T))")
            (("" (typepred "parsing(P_exp, A, e, inp, s, s_T)")
              (("" (use "Wellformed_theorem" ("T" "T0"))
                (("" (assert)
                  (("" (flatten)
                    (("" (assert)
                      (("" (expand "semppCompact" 3)
                        (("" (expand "parsing" 3)
                          (("" (expand "s_inp" 3)
                            (("" (expand "astType?" 3)
                              ((""
                                (lift-if 3)
                                ((""
                                  (split 3)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((V_T formal-nonempty-type-decl nil semantic_parser nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[V_T])" semantic_parser nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (V_N_b formal-const-decl "{k: nat | k > 0}" semantic_parser nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (bound formal-const-decl "posnat" semantic_parser nil)
    (V_S formal-type-decl nil semantic_parser nil)
    (pre_ast type-decl nil pre_ast nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (V_N type-eq-decl nil nTpred_order nil)
    (semanticTree? const-decl "bool" pre_ast nil)
    (semanticTree type-eq-decl nil pre_ast nil)
    (semantic_interp type-eq-decl nil semantic_interp nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (skip? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (star? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (astType type-decl nil ast nil)
    (astType? def-decl "astType" ast nil)
    (failure? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (failure adt-constructor-decl "(failure?)" ast nil)
    (fail? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (plus? adt-recognizer-decl "[pre_ast -> boolean]" pre_ast nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil pre_ast nil)
    (s shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (e shared-adt-accessor-decl "[pre_ast -> below]" pre_ast nil)
    (astWellformed? def-decl "bool" ast nil)
    (s_inp def-decl "{T': semanticTree |
   ((skip?(T) ⇔ skip?(T')) ∧
     (star?(T) ⇔ star?(T')) ∧
      ((astType?(T) = failure) ⇔ fail?(T')) ∧
       ((plus?(T) ⇒ (plus?(T') ∨ fail?(T')))))
    ∧
    (s(T') = s(T)) ∧
     (e(T') = e(T)) ∧
      (astWellformed?(T) ⇒
        (astWellformed?(T') ∧ (astType?(T') = astType?(T))))}"
     semantic_interp nil)
    (WF_nT type-eq-decl nil wf_peg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (peg type-decl nil peg nil)
    (subterm adt-def-decl "boolean" peg nil)
    (interp type-eq-decl nil wf_peg nil)
    (strong_WF const-decl "bool" wf_peg nil)
    (inp_bound type-eq-decl nil ast_props nil)
    (input type-eq-decl nil ast_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (g_wf def-decl "bool" wf_peg nil)
    (P_0c? const-decl "[Δ -> bool]" wf_peg nil)
    (strong const-decl "bool" wf_peg nil)
    (ast type-eq-decl nil ast nil)
    (star? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (plus? adt-recognizer-decl "[peg -> boolean]" peg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (trueToGrammar def-decl "bool" ast_props nil)
    (trueToInput def-decl "bool" ast_props nil)
    (success? adt-recognizer-decl "[astType -> boolean]" ast nil)
    (success adt-constructor-decl "(success?)" ast nil)
    (P_sc? const-decl "[Δ -> bool]" wf_peg nil)
    (P_fc? const-decl "[Δ -> bool]" wf_peg nil)
    (output type-eq-decl nil peg_parser nil)
    (parsing def-decl "output(P_exp, A, G, inp, s, s_T)" peg_parser
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semppCompact const-decl "pre_ast" semantic_interp nil)
    (Wellformed_theorem formula-decl nil ast nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (sempp subtype
    "semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].semppCompact(pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].andP(semantic_parser.s, semantic_parser.s, semantic_parser.T), semantic_parser.G)"
    "{T: pre_ast[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].pre_ast | T = semantic_interp[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].s_inp(semantic_parser.P_inp, peg_parser[semantic_parser.V_T, semantic_parser.<=, semantic_parser.V_N_b, semantic_parser.bound, semantic_parser.V_S].parsing(semantic_parser.P_exp, semantic_parser.A, semantic_parser.G, semantic_parser.inp, semantic_parser.s, semantic_parser.s_T))}"))))

